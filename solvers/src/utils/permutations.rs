use permutohedron::Heap;

/// Map the permutations generated by Heap's algorithm of the borrowed data.
///
/// ## Notes
/// - The order is not the usual one (see Heap's algorithm).
/// - The iterator does not allocate on the heap or clone any element.
/// - There are `factorial(data.len())` permutations.
pub fn map<D, N, F, T>(data: &mut D, func: F) -> Iter<'_, D, N, F>
where
    D: AsMut<[N]>,
    F: FnMut(&[N]) -> T,
{
    Iter::new(data, func)
}

pub struct Iter<'a, D, N, F> {
    heap: Heap<'a, D, N>,
    func: F,
}

impl<'a, D: AsMut<[N]>, N, F> Iter<'a, D, N, F> {
    fn new(data: &'a mut D, func: F) -> Self {
        Self {
            heap: Heap::new(data),
            func,
        }
    }

    /// Reset the permutations walker, without changing the data. It allows
    /// generating permutations again with the current state as starting
    /// point.
    pub fn reset(&mut self) {
        self.heap.reset();
    }
}

impl<'a, D, N, F, T> Iterator for Iter<'a, D, N, F>
where
    D: AsMut<[N]>,
    F: FnMut(&[N]) -> T,
{
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        self.heap
            .next_permutation()
            .map(|perm| (self.func)(perm.as_mut()))
    }
}
